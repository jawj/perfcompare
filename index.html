<link rel="stylesheet" href="index.css">
<body>
  <h2>Custom JSON parsing in JavaScript: important, now also conformant and performant</h2>
  <h3>JSON in Postgres</h3>
  <p>
    JSON is a popular data format. It's simple, human-readable, and can be serialized/deserialized almost anywhere.
  </p>
  <p>
    I used JSON in my first production Postgres database, which sat behind a back-end API for my research app <i>Mappiness</i>. The app could send back any data it liked as JSON. The API would pick out the fields it understood, and store and index them as ordinary columns. Then it shoved the whole JSON object into its own column, preserving all the other data that I later analysed in my research.
  </p>
  <p>
    Back then, in 2010, this data just went into the database as `text`. But it wasn't too long before Postgres added a native JSON type (with version 9.2 in 2012). Its JSON support has become steadily more powerful since then. You can now use Postgres not just to store JSON, but to transform and return complex query results. For example, my TypeScript/Postgres library, Zapatos, uses Postgres JSON functions to <a href="https://jawj.github.io/zapatos/#joins-as-nested-json">build handy nested structures out of lateral joins</a>.
  </p>
  <h3>Trouble with numbers</h3>
  <p>
    But there's a problem when we use JSON to communicate values between Postgres and JavaScript. 
  </p>
  <p>
    JavaScript has one kind of number: an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">IEEE 754 `float64`</a>. Postgres, of course, has many kinds. Some of these, like `bigint` or `numeric`, can represent larger and/or more precise numbers than a `float64`.
  </p>
  <p>
    JavaScript Postgres drivers typically parse these values into strings. For example:
  <code>
    await { rows } = pool.query('SELECT (1e16 + 1)::bigint AS big');
    // -> [{ big: '10000000000000001' }]
  </code>
  <p>This leaves you to choose how to deal with them in your code. In this case, you'd probably pass the Postgres `bigint` value to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">`BigInt(string)`</a>.
  </p>
  <p>
    Now, what if you return the same number as a JSON value? Perhaps surprisingly, <a href="https://www.json.org/json-en.html">the JSON spec</a> allows arbitrarily large numbers, so Postgres goes right ahead and encodes them. Then the JSON is parsed using JavaScript's `JSON.parse`, and bad things happen.
  </p>
  <code>
    await { rows } = pool.query('SELECT to_json((1e16 + 1)::bigint) AS big');
    // -> [{ big: 10000000000000000 }]
  </code>
  <p>
    Compare the two results above. That's right: without any warning, the number we got out of the second query is not the number Postgres sent.
  </p>
  <p>The solution</p>
  <p>
    The solution to this is to roll your own JSON parser, and tell your Postgres driver to use it for JSON values. For node-postgres (and thus also @neondatabase/serverless), you do it like this:
  </p>
  <code>
    import { types } from 'pg';
    function myJSONParse(json) { /* ... implementation ... */ }
    types.setTypeParser(types.builtins.JSONB, myJSONParse);
  </code>
  <p>
    (You might have thought that you could use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#the_reviver_parameter">the `reviver` argument to native `JSON.parse`</a> to avoid implementing a complete JSON parser. Sadly, you can't: by the time the function you supply here sees a number, it's already been parsed to a JavaScript `float64`, and the damage is done).
  </p>

  <h2>Crockford reference</h2>
  <div id="conform-crockford"></div>
  <div id="compare-crockford"></div> (slower: Chrome 8.4x, Safari 6.8x, Firefox 9.3x)

  <h2>json-bigint</h2>
  <div id="conform-json-bigint"></div>
  <div id="compare-json-bigint"></div> (slower: Chrome 8.1x, Safari 5.6x, Firefox 7.8x)

  <h2>lossless-json</h2>
  <div id="conform-lossless-json"></div>
  <div id="compare-lossless-json"></div> (slower: Chrome 6.0x, Safari 5.1x, Firefox 6.2x)

  <h2>json-custom-numbers</h2>
  <div id="conform-json-custom-numbers"></div>
  <div id="compare-json-custom-numbers"></div> (slower: Chrome 2.0x, Safari 1.7x, Firefox 1.7x)


  <div id="long-strings"></div> (slower: Firefox 6.1x, Chome 7.2x, Safari 14.5x)
  <div id="long-strings-quicker"></div>

  <div id="conform2"></div>
  <div id="compare2"></div> (slower: Safari 1.6x, Chrome 1.7x, Firefox 2.2x)
  <img id="svg">
  <div id="log"></div>
</body>
<script src="index.js"></script>